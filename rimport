#!/glade/u/apps/derecho/24.12/opt/view/bin/python
# TODO: Move all the Python into new file rimport.py for simpler testing. Keep rimport as a
# convenience wrapper.
"""
Copy files from CESM inputdata directory to a publishing directory.

Do `rimport --help` for more information.
"""
from __future__ import annotations

import argparse
import os
import pwd
import shutil
import sys
from pathlib import Path
from typing import Iterable, List

DEFAULT_INPUTDATA_ROOT = Path("/glade/campaign/cesm/cesmdata/cseg/inputdata")
DEFAULT_STAGING_ROOT = Path(
    "/glade/campaign/collections/gdex/data/d651077/cesmdata/inputdata"
)
STAGE_OWNER = "cesmdata"


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Copy files from CESM inputdata directory to a publishing directory."
    )

    # Mutually exclusive: -file or -list (one required)
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument(
        "-file",
        dest="file",
        metavar="filename",
        help="Provide a single filename relative to the top inputdata directory",
    )
    group.add_argument(
        "-list",
        dest="filelist",
        metavar="filelist",
        help=(
            "Provide a file that contains a list of filenames to import. All filenames in the list"
            "are relative to the top inputdata area."
        ),
    )

    parser.add_argument(
        "-inputdata",
        dest="inputdata",
        metavar="inputdata_dir",
        default=DEFAULT_INPUTDATA_ROOT,
        help=(
            "Change the default local top level inputdata directory."
            f" Default: '{DEFAULT_INPUTDATA_ROOT}'"
        ),
    )

    return parser


def read_filelist(list_path: Path) -> List[str]:
    """Read list file, ignoring blank lines and comments starting with #."""
    lines: List[str] = []
    with list_path.open("r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line or line.startswith("#"):
                continue
            lines.append(line)
    return lines


def resolve_paths(root: Path, relnames: Iterable[str]) -> List[Path]:
    paths: List[Path] = []
    for name in relnames:
        p = (
            (root / name).resolve()
            if not Path(name).is_absolute()
            else Path(name).resolve()
        )
        paths.append(p)
    return paths


def stage_data(src: Path, inputdata_root: Path, staging_root: Path) -> None:
    """Stage a file by mirroring its path under `staging_root`.
    Destination path is computed by replacing the `args.inputdata` prefix of `src`
    with `staging_root`, i.e.:
    dst = staging_root / src.relative_to(inputdata_root)

    Guardrails:
    * Raise if `src` is a *live* symlink ("already published").
    * Raise if `src` is a broken symlink or is outside the inputdata root.
    """
    if src.is_symlink() and src.exists():
        # TODO: This should be a regular message, not an error.
        raise RuntimeError("File is already published.")
    if src.is_symlink() and not src.exists():
        raise RuntimeError(f"Source is a broken symlink: {src}")
    if not src.exists():
        raise FileNotFoundError(f"source not found: {src}")

    try:
        rel = src.resolve().relative_to(inputdata_root.resolve())
    except ValueError as exc:
        if src.resolve().is_relative_to(staging_root.resolve()):
            raise RuntimeError(
                f"Source file '{src.name}' is already under staging directory '{staging_root}'."
            ) from exc
        raise RuntimeError(
            f"source not under inputdata root: {src} not in {inputdata_root}"
        ) from exc

    dst = staging_root / rel
    dst.parent.mkdir(parents=True, exist_ok=True)
    shutil.copy2(src, dst)
    print(f"[rimport] staged {src} -> {dst}")


def ensure_running_as(target_user: str, argv: list[str]) -> None:
    """If not running as `target_user`, re-exec via sudo -u target_user (handles 2FA via PAM)."""
    try:
        target_uid = pwd.getpwnam(target_user).pw_uid
    except KeyError as exc:
        print(
            f"rimport: target user '{target_user}' not found on this system",
            file=sys.stderr,
        )
        raise SystemExit(2) from exc

    if os.geteuid() != target_uid:
        try:
            assert sys.stdin.isatty()
        except AssertionError as exc:
            print(
                f"rimport: need interactive TTY to authenticate as '{target_user}' (2FA).\n"
                f"         Try: sudo -u {target_user} rimport …",
                file=sys.stderr,
            )
            raise SystemExit(2) from exc
        # Re-exec under target user; this invokes sudo’s normal password/2FA flow.
        os.execvp("sudo", ["sudo", "-u", target_user, "--"] + argv)


def get_staging_root() -> Path:
    """Return the staging root. Uses $RIMPORT_STAGING if set, otherwise
    creates a sibling directory named '<inputdata_root>.staging'."""
    env = os.getenv("RIMPORT_STAGING")
    if env:
        return Path(env).expanduser().resolve()
    return DEFAULT_STAGING_ROOT


def main(argv: List[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    # Ensure we are running as the STAGE_OWNER account before touching the tree
    # Set env var RIMPORT_SKIP_USER_CHECK=1 if you prefer to run `sudox -u STAGE_OWNER rimport …`
    # explicitly (or for testing).
    if os.getenv("RIMPORT_SKIP_USER_CHECK") != "1":
        ensure_running_as(STAGE_OWNER, sys.argv)

    root = Path(args.inputdata).expanduser().resolve()
    if not root.exists():
        print(f"rimport: inputdata directory does not exist: {root}", file=sys.stderr)
        return 2

    # Determine the list of relative filenames to handle
    if args.file is not None:
        relnames = [args.file]
    else:
        list_path = Path(args.filelist).expanduser().resolve()
        if not list_path.exists():
            print(f"rimport: list file not found: {list_path}", file=sys.stderr)
            return 2
        relnames = read_filelist(list_path)
        if not relnames:
            print(f"rimport: no filenames found in list: {list_path}", file=sys.stderr)
            return 2

    # Resolve to full paths (keep accepting absolute names too)
    paths = resolve_paths(root, relnames)
    staging_root = get_staging_root()
    # Execute the new action per file
    errors = 0
    for p in paths:
        try:
            stage_data(p, root, staging_root)
        except Exception as e:  # Keep CLI robust for batch runs
            errors += 1
            print(f"rimport: error processing {p}: {e}", file=sys.stderr)

    return 0 if errors == 0 else 1


if __name__ == "__main__":
    raise SystemExit(main())
